import 'dart:io';
import 'package:path/path.dart' as p;
import 'scanner.dart';

class Generator {
  final String projectRoot;
  Generator(this.projectRoot);

  Future<void> generate(ScanResult scan) async {
    final outDir = p.join(projectRoot, 'lib', 'core', 'assets');
    Directory(outDir).createSync(recursive: true);
    final outFile = File(p.join(outDir, 'app_assets.dart'));

    final buffer = StringBuffer();

    // count up assets by type for the header
    final imagesCount = scan.groups.firstWhere((g) => g.groupName.toLowerCase() == 'images', orElse: () => AssetGroup('', [])).files.length;
    final fontsCount = scan.groups.firstWhere((g) => g.groupName.toLowerCase() == 'fonts', orElse: () => AssetGroup('', [])).files.length;
    final lottieCount = scan.groups.firstWhere((g) => g.groupName.toLowerCase() == 'lottie', orElse: () => AssetGroup('', [])).files.length;

    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by fsa (Flutter Smart Assets) - safe mode');
    buffer.writeln('// Assets: ${scan.totalFiles} files | Images: $imagesCount | Fonts: $fontsCount | Lottie: $lottieCount');
    buffer.writeln('');

    buffer.writeln('/// quick access to all asset groups');
    buffer.writeln('class AppAssets {');
    buffer.writeln('  AppAssets._();');

    // collect class names so we can reference them in the aggregator
    final availableClasses = <String, String>{}; // className -> propertyName
    for (final group in scan.groups) {
      final className = 'App${_toPascal(group.groupName.isEmpty ? 'Assets' : group.groupName)}';
      final propName = _toLowerCamel(group.groupName.isEmpty ? 'assets' : group.groupName);
      availableClasses[className] = propName;
      // Map will be used after writing aggregator header content
    }

    // write properties that point to each group class
    for (final entry in availableClasses.entries) {
      // property name is just the folder name in lowerCamel
      final className = entry.key;
      final property = entry.value;
      buffer.writeln('  static const $property = $className;');
    }
    buffer.writeln('}');
    buffer.writeln('');

    // generate a class for each group
    for (final group in scan.groups) {
      final folder = group.groupName.isEmpty ? 'assets' : group.groupName;
      final className = 'App${_toPascal(folder)}';
      buffer.writeln('/// asset group: ${_toPascal(folder)}');
      buffer.writeln('class $className {');
      buffer.writeln('  $className._();');

      for (final fileEntry in group.files) {
        final rel = p.relative(fileEntry.path, from: projectRoot).replaceAll('\\', '/');
        final varName = _makeConstantNameFromPath(rel);
        buffer.writeln("  static const String $varName = '$rel';");
      }

      buffer.writeln('}');
      buffer.writeln('');
    }

    // Font family names class (if we have fonts)
    final fontsGroup = scan.groups.firstWhere((g) => g.groupName.toLowerCase() == 'fonts', orElse: () => AssetGroup('', []));
    if (fontsGroup.files.isNotEmpty) {
      // extract family names (first token before -/_/space)
      final families = <String>{};
      for (final f in fontsGroup.files) {
        final rel = p.relative(f.path, from: projectRoot).replaceAll('\\', '/');
        final filename = p.basenameWithoutExtension(rel);
        final family = _extractFamily(filename);
        families.add(family);
      }

      buffer.writeln('/// font family names');
      buffer.writeln('class AppFontFamilies {');
      buffer.writeln('  AppFontFamilies._();');
      for (final fam in families) {
        final constName = _toUpperCamel(fam); // MANROPE -> MANROPE
        buffer.writeln("  static const String $constName = '$fam';");
      }
      buffer.writeln('}');
      buffer.writeln('');
    }

    await outFile.writeAsString(buffer.toString());
  }

  String _extractFamily(String filename) {
    final separators = ['-', '_', ' '];
    for (final s in separators) {
      if (filename.contains(s)) return filename.split(s).first;
    }
    return filename;
  }

  // rules for making constant names:
  // - uppercase with underscores
  // - keep format suffix (PNG, SVG, TTF, JSON, MP4, etc.)
  // - use nested folder names as parts separated by underscores
  // - if file starts with digit -> prefix with underscore
  String _makeConstantNameFromPath(String relPath) {
    // relPath example: assets/images/icons/home.png
    final parts = relPath.split('/');
    // drop the root 'assets' part
    final withoutRoot = parts.skipWhile((p) => p.toLowerCase() != 'assets').toList();
    if (withoutRoot.isNotEmpty && withoutRoot.first.toLowerCase() == 'assets') {
      withoutRoot.removeAt(0);
    }
    // now we have like ['images','icons','home.png']
    final last = withoutRoot.isNotEmpty ? withoutRoot.last : '';
    final fileName = last;
    final extension = p.extension(fileName).replaceFirst('.', '').toUpperCase(); // PNG
    final nameWithoutExt = p.basenameWithoutExtension(fileName);
    final nameParts = <String>[];
    // use all folder parts (excluding final file) + filename base (split by -,_,space)
    final folderParts = withoutRoot.length > 1 ? withoutRoot.sublist(0, withoutRoot.length - 1) : <String>[];
    for (final fp in folderParts) {
      nameParts.addAll(_splitToTokens(fp));
    }
    nameParts.addAll(_splitToTokens(nameWithoutExt));
    // join tokens with underscore and uppercase
    var candidate = nameParts.map((t) => t.toUpperCase()).join('_');
    // append format suffix
    candidate = '${candidate}_$extension';
    // if it starts with a digit -> prefix with underscore
    if (candidate.isNotEmpty && RegExp(r'^[0-9]').hasMatch(candidate[0])) {
      candidate = '_$candidate';
    }
    // make sure it's a valid dart identifier (letters, digits, underscores only)
    candidate = candidate.replaceAll(RegExp(r'[^A-Z0-9_]'), '_');
    return candidate;
  }

  List<String> _splitToTokens(String s) {
    // split on non-alphanumeric stuff (dash, underscore, spaces)
    final tokens = RegExp(r'[A-Za-z0-9]+').allMatches(s).map((m) => m.group(0)!).toList();
    return tokens;
  }

  String _toPascal(String input) {
    final parts = RegExp(r'[A-Za-z0-9]+').allMatches(input).map((m) => m.group(0)!).toList();
    return parts.map((p) => p[0].toUpperCase() + (p.length > 1 ? p.substring(1) : '')).join();
  }

  String _toLowerCamel(String input) {
    final pas = _toPascal(input);
    if (pas.isEmpty) return '';
    return pas[0].toLowerCase() + (pas.length > 1 ? pas.substring(1) : '');
  }

  String _toUpperCamel(String input) {
    // for font family constants - just uppercase the whole thing
    return input.replaceAll(RegExp(r'[^A-Za-z0-9]'), '').toUpperCase();
  }
}
